# Лабораторная работа №1. Функциональное программирование

**Студент:** КДО  
**Группа:** [Группа]  
**Предмет:** Функциональное программирование  
**Дата:** 23 сентября 2025

---

## Описание проблемы

**Problem 14: Longest Collatz Sequence**

Задача из проекта Эйлера: найти число меньше одного миллиона, которое производит самую длинную последовательность Коллатца.

> Следующая итеративная последовательность определена для множества положительных целых чисел:
>
> n → n/2 (n четное)  
> n → 3n + 1 (n нечетное)
>
> Используя правило выше и начиная с 13, мы получаем следующую последовательность:  
> 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1.
>
> Можно увидеть, что эта последовательность (начинающаяся с 13 и заканчивающаяся на 1) содержит 10 элементов.
>
> Какое начальное число меньше одного миллиона производит самую длинную цепочку?

**Правильный ответ:** 837799

---

## Ключевые элементы реализации

### 1. Монолитная реализация с хвостовой рекурсией (task_1.ml)

```ocaml
(* Хвостовая рекурсия для вычисления длины последовательности *)
let rec collatz n acc =
  if n = 1 then acc
  else if n mod 2 = 0 then collatz(n/2)(acc + 1)
  else collatz(n*3 + 1)(acc + 1)

(* Хвостовая рекурсия для поиска максимума *)
let rec find_max_number_collatz n max_len max_number =
  if n <= 1 then max_number
  else let len = collatz(n)(1) in
  if max_len < len then find_max_number_collatz(n - 1)(len)(n)
  else find_max_number_collatz(n - 1)(max_len)(max_number)
```

**Особенности:**

- Использует аккумулятор для предотвращения переполнения стека
- Обходит числа в обратном порядке для оптимизации
- Эффективна по памяти для больших диапазонов

### 2. Модульная реализация с fold/filter (task_2.ml)

```ocaml
module GenerateSeq = struct
  let first_n_natural_number n = List.init n (fun i -> i + 1)
end

module FilteredUintSeq = struct
  let filtered_seq_even (lst: int list) = List.filter (fun x -> x mod 2 = 0) lst
  let filtered_seq_odd (lst: int list) = List.filter (fun x -> x mod 2 != 0) lst
end

module ReduceUintSeq = struct
  let collatz_seq lst =
    List.fold_left (fun (max_num, max_len) x ->
      let len = collatz x 1 in
      if len > max_len then (x,len)
      else (max_num, max_len)
    ) (1,0) lst
end

(* Объединение результатов четных и нечетных чисел *)
let ans =
  if snd first_n_num_even_collatz > snd first_n_num_odd_collatz
  then fst first_n_num_even_collatz
  else fst first_n_num_odd_collatz
```

**Особенности:**

- Разделение на четные и нечетные числа для анализа
- Использование fold_left для эффективной свертки
- Модульная архитектура для лучшей организации кода

### 3. Реализация с отображением (task_3.ml)

```ocaml
let collatz_for_seq x = collatz x 1
let num_seq = List.init n (fun x -> x + 1)

(* Отображение каждого числа в длину его последовательности *)
let lst_ans = List.map collatz_for_seq num_seq

(* Поиск индекса максимального элемента *)
let rec max_ans lst max_num max_len index = match lst with
| [] -> max_num
| h :: t -> max_ans(t)(if max_len < h then index else max_num)
                      (if max_len < h then h else max_len)(index + 1)
```

**Особенности:**

- Использует map для преобразования чисел в длины
- Отслеживает индексы для восстановления исходного числа
- Демонстрирует функциональный подход к обработке последовательностей

### 4. Реализация с циклами (task_4.ml)

```ocaml
let collatz_length n =
  let count = ref 0 in
  let current = ref n in
  while !current <> 1 do
    if !current mod 2 = 0 then
      current := !current / 2
    else
      current := 3 * !current + 1;
    incr count
  done;
  !count + 1

let find_max_collatz limit =
  let max_length = ref 0 in
  let max_number = ref 1 in

  for i = 1 to limit do
    let length = collatz_length i in
    if length > !max_length then begin
      max_length := length;
      max_number := i
    end
  done;
  (!max_number, !max_length)
```

**Особенности:**

- Императивный стиль с использованием ref и циклов
- Эффективен по памяти для больших диапазонов
- Привычен для программистов из императивных языков

### 5. Реализация с бесконечными последовательностями (task_5.ml)

```ocaml
let rec collatz_seq n =
  if n = 1 then
    fun () -> Seq.Cons (1, Seq.empty)
  else
    fun () ->
      let next = if n mod 2 = 0 then n / 2 else 3 * n + 1 in
      Seq.Cons (n, collatz_seq next)

let collatz_pairs =
  Seq.ints 1 |> Seq.map (fun n -> (n, collatz_length n))

let find_max_collatz limit =
  collatz_pairs
  |> Seq.take limit
  |> Seq.fold_left (fun (max_n, max_len) (n, len) ->
      if len > max_len then (n, len) else (max_n, max_len)
    ) (1, 1)
```

**Особенности:**

- Использует ленивые последовательности OCaml
- Бесконечный поток чисел с их длинами Коллатца
- Элегантное функциональное решение с pipe операторами

### 6. Реализация на Python (alg.py)

```python
def collatz_sequence(n: int) -> tuple[int, int]:
    max_len: int = 0
    max_num: int = 0
    for i in range(1, n):
        count: int = 1
        temp: int = i
        while temp != 1:
            if temp % 2 == 0:
                temp //= 2
            else:
                temp = 3*temp + 1
            count += 1
        if count > max_len:
            max_num = i
            max_len = count
    return max_num, max_len
```

**Особенности:**

- Простая императивная реализация
- Типизация для лучшей читаемости
- Эффективная для больших диапазонов

---

## Результаты выполнения

### OCaml реализации:

```
Result 1 (tail recursion): 837799
Result 2 (modular with fold/filter): 837799
Result 3 (with map): 837799
Result 4 (with loops): 837799
Result 5 (infinite sequences): 837799
```

### Python реализация:

```
(837799, 525)
```

---

## Выводы

### Анализ использованных приемов программирования

#### **1. Хвостовая рекурсия vs Обычная рекурсия**

- **Хвостовая рекурсия** критически важна для последовательности Коллатца, поскольку длина может достигать сотен элементов
- Использование аккумулятора предотвращает переполнение стека
- Компилятор OCaml оптимизирует хвостовую рекурсию в цикл

#### **2. Модульность с разделением по типам чисел**

- Интересный подход: разделение на четные и нечетные числа
- Позволяет анализировать различные паттерны в последовательностях
- Демонстрирует композицию результатов из разных модулей
- `fold_left` эффективно обрабатывает большие списки

#### **3. Отображения и индексация**

- `List.map` естественно преобразует числа в длины последовательностей
- Необходимость отслеживания индексов усложняет код
- Показывает важность выбора правильной структуры данных

#### **4. Императивные конструкции**

- Циклы `for` и `while` естественны для такого типа задач
- Мутабельные переменные `ref` позволяют эффективно отслеживать максимум
- Производительность часто выше функциональных аналогов

#### **5. Ленивые последовательности**

- `Seq` в OCaml предоставляет элегантное решение
- Бесконечные потоки позволяют работать с любыми диапазонами
- Pipe операторы (`|>`) улучшают читаемость кода
- Демонстрируют мощь функционального подхода

#### **6. Сравнение с традиционным языком (Python)**

- Python код более лаконичен для данной задачи
- Встроенная поддержка больших чисел
- Императивный стиль естественен для итеративных алгоритмов

### **Особенности задачи Коллатца:**

1. **Непредсказуемость последовательности** - длина может сильно варьироваться
2. **Вычислительная интенсивность** - требует обработки миллиона чисел
3. **Необходимость отслеживания максимума** - нужна эффективная агрегация

### **Общие выводы:**

1. **Хвостовая рекурсия** критически важна для глубоких вычислений
2. **Модульность** помогает исследовать различные аспекты данных
3. **Ленивые вычисления** предоставляют элегантные решения
4. **Императивные циклы** часто более эффективны для итеративных задач
5. **Выбор подхода** зависит от требований производительности и читаемости

Задача Коллатца демонстрирует, что разные парадигмы программирования могут быть эффективными для одной задачи, но выбор зависит от конкретных требований к производительности, читаемости и масштабируемости.

---

## Структура проекта

```
Task14/
├── lib/
│   ├── task_1.ml      # Хвостовая рекурсия
│   ├── task_2.ml      # Модульный подход
│   ├── task_3.ml      # Отображения (map)
│   ├── task_4.ml      # Циклы
│   ├── task_5.ml      # Бесконечные последовательности
│   ├── alg.py         # Python реализация
│   └── dune           # Конфигурация сборки
├── bin/
│   └── main.ml        # Точка входа
└── test/
    └── test_Lab1.ml   # Тесты
```

## Запуск

```bash
# Сборка OCaml
dune build

# Запуск OCaml реализаций
dune exec ./bin/main.exe

# Запуск Python реализации
python lib/alg.py
```
